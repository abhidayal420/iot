{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Calibri;}{\f1\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue0;}
{\*\generator Riched20 10.0.16299}\viewkind4\uc1 
\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\widctlpar\fi-360\li720\sa200\sl276\slmult1\qj\f0\fs24 Program to use GPIO with LED / Buzzer with interrupt int1/int0.\par

\pard\widctlpar\sa200\sl276\slmult1\qj #include <stdio.h>\par
#include "NUC1xx.h"\par
#include "Driver\\DrvGPIO.h"\par
#include "Driver\\DrvUART.h"\par
#include "Driver\\DrvSYS.h"\par
\par
void Init_LED() // Initialize GPIO pins\par
\{\par
    DrvGPIO_Open(E_GPC, 15, E_IO_OUTPUT); // GPC12 pin set to output mode\par
    DrvGPIO_SetBit(E_GPC, 15);            // Goutput Hi to turn off LED\par
\}\par
\par
void EINT0Led_CALLBACK(void)\par
\{\par
    DrvGPIO_ClrBit(E_GPC, 15); //turns on LED\par
    DrvSYS_Delay(300000);      \par
    DrvGPIO_SetBit(E_GPC, 15); //turns off LED\par
    DrvSYS_Delay(300000);      \par
\}\par
\par
void EINT1Callback(void)\par
\{\par
    DrvGPIO_ClrBit(E_GPB,11);  //turns on Buzzer\par
    DrvSYS_Delay(100000);       \par
    DrvGPIO_SetBit(E_GPB,11);  //turns off Buzzer   \par
    DrvSYS_Delay(100000);         \par
\}\par
   \par
int main (void)\par
\{\par
\tab UNLOCKREG();                \par
  DrvSYS_Open(48000000);\par
  LOCKREG();                  \par
\par
  Init_LED();      \par
  DrvGPIO_Open(E_GPB, 14, E_IO_INPUT); //for LED\par
  DrvGPIO_EnableEINT0(E_IO_RISING, E_MODE_EDGE, EINT0Led_CALLBACK);     //GPIO port E_GPB, pin 14\par
   \par
  DrvGPIO_Open(E_GPB, 11, E_IO_OUTPUT); //for buzzer  \par
  DrvGPIO_Open(E_GPB, 15, E_IO_INPUT);  // configure external interrupt pin GPB15\par
\par
  DrvGPIO_EnableEINT1(E_IO_BOTH_EDGE, E_MODE_EDGE, EINT1Callback); \par
\par
  while(1)\par
    \{\par
    \}\par
\}\par
\par

\pard\widctlpar\li360\sa200\sl276\slmult1\qj 2.Program to use GPIO as input from A port and display the port bit number.\par

\pard 
{\pntext\f0 1)\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta)}}
\widctlpar\fi-360\li1080\sa200\sl276\slmult1\fs22 Get port number gpio\par

\pard\widctlpar\li720\sa200\sl276\slmult1 //#include <stdio.h>\par
#include "NUC1xx.h"\par
#include "Driver\\DrvSYS.h"\par
#include "Driver\\DrvGPIO.h"\par
\par
\par
\par
int main (void)\par
\{\par
\tab int32_t a;\par
\tab char text[16];\par
\tab UNLOCKREG();\tab\tab\tab     // unlock register for programming\par
  DrvSYS_Open(48000000);// set System Clock to run at 48MHz \par
\tab                       // 12MHz crystal input, PLL output 48MHz\par
\tab LOCKREG();\tab\tab\tab\tab     // lock register from programming\par
\par
          // Initialize LEDs (four on-board LEDs below LCD panel)\tab\par
  Initial_panel();\par
\tab clr_all_panel();\par
\tab while (1)\tab\tab\tab\tab    // forever loop to keep flashing four LEDs one at a time\par
\tab\{\par
\tab\tab DrvGPIO_SetPortBits(E_GPA,0);\par
\tab a=DrvGPIO_GetPortBits(E_GPA);\tab  \par
   sprintf(text,"port number %d",a);\tab\tab // delay\par
\tab  print_lcd(0,text);\par
\tab\tab\}\par
\}\par
\par

\pard\widctlpar\li360\sa200\sl276\slmult1\qj\fs24 3.Program interrupt with port A and identify the A port bit that was interrupted and increment the counter to count the number of interrupts.\par
#include <stdio.h>\par
#include "NUC1xx.h"\par
#include "Driver\\DrvUART.h"\par
#include "Driver\\DrvGPIO.h"\par
#include "Driver\\DrvSYS.h"\par
#include "LCD_Driver.h"\par
\par
volatile uint32_t irqA_counter = 0;\par
\par
\par
void GPIOAB_INT_CallBack(uint32_t GPA_IntStatus, uint32_t GPB_IntStatus)\par
\{\par
\tab  int32_t a;\par
\tab  char text[16];\par
\tab  DrvGPIO_SetPortBits(E_GPA,0);\par
\tab a=DrvGPIO_GetPortBits(E_GPA);\par
\tab  if ((GPA_IntStatus>>0) & 0x01) irqA_counter++;\par
\tab  sprintf(text,"port number %d",a);\par
\tab  print_lcd(3,"GPA interrupt !! ");\par
\tab  print_lcd(2,text);\par
\}\par
\par
\par
\par
int32_t main()\par
\{\par
\tab char TEXT[16];\par
\par
\tab UNLOCKREG();\par
\tab SYSCLK->PWRCON.XTL12M_EN=1;\par
\tab DrvSYS_Delay(5000);\tab\tab\tab\tab\tab // Waiting for 12M Xtal stalble\par
\tab SYSCLK->CLKSEL0.HCLK_S=0;\par
\tab LOCKREG();\par
\par
  // setup GPA15 & GPD15 to get interrupt input\par
\tab\par
\tab DrvGPIO_Open(E_GPA,0,E_IO_INPUT);\par
\tab DrvGPIO_EnableInt(E_GPA, 0, E_IO_RISING, E_MODE_EDGE);\par
  DrvGPIO_SetDebounceTime(5, 1);\par
\tab DrvGPIO_EnableDebounce(E_GPA, 0);\par
\tab\par
  DrvGPIO_SetIntCallback(GPIOAB_INT_CallBack,NULL);\par
\par
  Initial_panel();\par
\tab clr_all_panel();\par
    \tab\tab\tab\tab\par
\tab print_lcd(0,"Smpl_GPIO_Intr");\par
\tab\par
\tab while(1)\par
\tab\{\par
\tab\tab sprintf(TEXT,"IRQ_A: %d",irqA_counter);\par
\tab\tab print_lcd(1, TEXT);\par
\tab\tab\par
\tab\}\par
\}\par
4.Program for using ADC  channel 6  and display analog value on the LCD.\par
\par

\pard\widctlpar\li720\sa200\sl276\slmult1\qj #include <stdio.h>\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab  \par
#include "NUC1xx.h"\par
#include "Driver\\DrvSYS.h"\par
#include "Seven_Segment.h"\par
#include "DrvADC.h"\par
#include "LCD_Driver.h"\par
\par
\tab  \par
 int32_t main (void)\par
\{  uint16_t value;  \par
    char TEXT[16];\tab\tab\tab    \par
\tab\par
\tab UNLOCKREG();\par
\tab SYSCLK->PWRCON.XTL12M_EN = 1; \tab //Enable 12Mhz and set HCLK->12Mhz\par
\tab SYSCLK->CLKSEL0.HCLK_S = 0;\par
\tab LOCKREG();\par
\tab Initial_panel();  // initialize LCD pannel\par
  clr_all_panel();  // clear LCD panel \par
  print_lcd(0,"variable reistor");\par
\par
\tab DrvADC_Open(ADC_SINGLE_END,ADC_SINGLE_OP , 0x40,INTERNAL_HCLK , 1); \tab\par
\tab while(1)\par
   \{\par
    DrvADC_StartConvert();   // start A/D conversion\par
    while(DrvADC_IsConversionDone()==FALSE);\par
    value = ADC->ADDR[6].RSLT & 0xFFF;    \par
    \par
    sprintf(TEXT,"Value: %d",value); // convert ADC0 value into text\par
    print_lcd(1, TEXT); // output TEXT to LCD\par
   \par
    \}\par
\}\par

\pard 
{\pntext\f0 5.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart5\pndec{\pntxta.}}
\widctlpar\fi-360\li720\sa200\sl276\slmult1\qj Program for using ADC channel 0 and display value on the 7 segment.\par

\pard\widctlpar\li720\sa200\sl276\slmult1\qj\par

\pard\widctlpar\sa200\sl276\slmult1\qj #include <stdio.h>\par
#include "NUC1xx.h"\par
#include "Driver\\DrvSYS.h"\par
#include "Seven_Segment.h"\par
void InitADC(void)\par
\{\par
\tab /* Step 1. GPIO initial */\par
\tab //Should be 0x00010000 \par
\tab GPIOA->OFFD|=0x00010000; //Disable digital input path\par
\tab SYS->GPAMFP.ADC7_SS21_AD6=1; //Set ADC function\par
\tab\par
\tab /* Step 2. Enable and Select ADC clock source, and then enable ADC module */\par
\tab SYSCLK->CLKSEL1.ADC_S = 2; //Select 22Mhz for ADC\par
\tab SYSCLK->CLKDIV.ADC_N = 1; //ADC clock source = 22Mhz/2 =11Mhz;\par
\tab SYSCLK->APBCLK.ADC_EN = 1; //Enable clock source\par
\tab ADC->ADCR.ADEN = 1; //Enable ADC module\par
\par
\tab /* Step 3. Select Operation mode */\par
\tab ADC->ADCR.DIFFEN = 0; //single end input\par
\tab ADC->ADCR.ADMD = 0; //single mode\par
\tab //Should be 0x01(In Q4 0x40)\par
\tab\par
\tab /* Step 4. Select ADC channel 0*/\par
\tab ADC->ADCHER.CHEN = 0x01;\par
\par
\tab /* Step 5. Enable ADC interrupt */\par
\tab ADC->ADSR.ADF =1; //clear the A/D interrupt flags for safe\par
\tab ADC->ADCR.ADIE = 1;\par
\tab // NVIC_EnableIRQ(ADC_IRQn);\par
\par
\tab /* Step 6. Enable WDT module */\par
\tab ADC->ADCR.ADST=1;\par
\}\par
void seg_display(int16_t value)\par
\{\par
\tab int8_t digit;\par
\tab digit = value / 1000;\par
\tab close_seven_segment();\par
\tab show_seven_segment(3,digit);\par
\tab DrvSYS_Delay(5000);\par
\par
\tab value = value - digit * 1000;\par
\tab digit = value / 100;\par
\tab close_seven_segment();\par
\tab show_seven_segment(2,digit);\par
\tab DrvSYS_Delay(5000);\par
\par
\tab value = value - digit * 100;\par
\tab digit = value / 10;\par
\tab close_seven_segment();\par
\tab show_seven_segment(1,digit);\par
\tab DrvSYS_Delay(5000);\par
\par
\tab value = value - digit * 10;\par
\tab digit = value;\par
\tab close_seven_segment();\par
\tab show_seven_segment(0,digit);\par
\tab DrvSYS_Delay(5000);\par
\}\par
int32_t main (void)\par
\{\par
\tab int32_t adc_value;\par
\tab UNLOCKREG();\par
\tab SYSCLK->PWRCON.XTL12M_EN = 1; //Enable 12Mhz and set HCLK->12Mhz\tab\par
\tab SYSCLK->CLKSEL0.HCLK_S = 0;\tab\par
\tab LOCKREG();\par
\tab InitADC();\par
\tab while(1)\par
\tab\{\par
\tab\tab while(ADC->ADSR.ADF==0); // ADC Flag, wait till 1 (A/DC conversion done)\par
\tab\tab ADC->ADSR.ADF=1; // write 1 to ADF is to clear the flag\par
\par
\tab\tab adc_value=ADC->ADDR[0].RSLT; // input 12-bit ADC value\par
\tab\tab seg_display(adc_value); // display value to 7-segment display\par
\tab\tab ADC->ADCR.ADST=1;       //from step 6 \par
\tab\}\par
\}\par

\pard\widctlpar\li360\sa200\sl276\slmult1\qj 6.Program pwm1  and adc channel 6 and change the illumination of led ( use ADC and PWM).\par
\par

\pard\widctlpar\qj #include <stdio.h> \~\par
#include "NUC1xx.h"\par
#include "LCD_Driver.h"\par
#define BAUDRATE 9600\par
\par
void InitADC(void)\par
\{\par
/* Step 1. GPIO initial */\~\par
GPIOA->OFFD|=0x00400000; //Disable digital input path\par
SYS->GPAMFP.ADC7_SS21_AD6=1; //Set ADC function\~\par
/* Step 2. Enable and Select ADC clock source, and then enable ADC module */ \~ \~ \~ \~ \~\par
SYSCLK->CLKSEL1.ADC_S = 2; //Select 22Mhz for ADC\par
SYSCLK->CLKDIV.ADC_N = 1; //ADC clock source = 22Mhz/2 =11Mhz;\par
SYSCLK->APBCLK.ADC_EN = 1; //Enable clock source\par
ADC->ADCR.ADEN = 1; //Enable ADC module\par
\par
/* Step 3. Select Operation mode */\par
ADC->ADCR.DIFFEN = 0; \~ \~ //single end input\par
ADC->ADCR.ADMD \~ = 0; \~ \~ //single mode\par
/* Step 4. Select ADC channel */\par
ADC->ADCHER.CHEN = 0x40;\par
/* Step 5. Enable ADC interrupt */\par
ADC->ADSR.ADF =1; \~ \~ //clear the A/D interrupt flags for safe\~\par
ADC->ADCR.ADIE = 1;\par
// NVIC_EnableIRQ(ADC_IRQn);\par
/* Step 6. Enable WDT module */\par
ADC->ADCR.ADST=1;\par
\}\par
//--------------------------------------------\par
void InitPWM(void)\par
\{\par
\~ /* Step 1. GPIO initial */\~\par
SYS->GPAMFP.PWM0_AD13=1;\par
/* Step 2. Enable and Select PWM clock source*/ \par
SYSCLK->APBCLK.PWM01_EN = 1;//Enable PWM clock\par
SYSCLK->CLKSEL1.PWM01_S = 3;//Select 22.1184Mhz for PWM clock source\par
\par
PWMA->PPR.CP01=1; //Prescaler 0~255, Setting 0 to stop output clock\par
PWMA->CSR.CSR0=0; // PWM clock = clock source/(Prescaler + 1)/divider\par
\~ \~ \~ \~\~\par
/* Step 3. Select PWM Operation mode */\par
//PWM0\par
PWMA->PCR.CH0MOD=1; //0:One-shot mode, 1:Auto-load mode\par
//CNR and CMR will be auto-cleared after setting CH0MOD form 0 to 1.\par
PWMA->CNR0=0xFFFF;\par
PWMA->CMR0=0xFFFF;\par
\par
PWMA->PCR.CH0INV=0; //Inverter->0:off, 1:on\par
PWMA->PCR.CH0EN=1; //PWM function->0:Disable, 1:Enable\par
\~ PWMA->POE.PWM0=1; //Output to pin->0:Diasble, 1:Enable\par
\}\par
\par
void Delay(int count)\par
\{\par
while(count--)\par
\{\par
// __NOP;\par
\}\par
\}\par
\par
/*----------------------------------------------------------------------------\par
\~ MAIN function\par
\~ ----------------------------------------------------------------------------*/\par
int32_t main (void)\par
\{\par
//Enable 12Mhz and set HCLK->12Mhz\par
char adc_value[15]="ADC Value:"; \par
UNLOCKREG();\par
SYSCLK->PWRCON.XTL12M_EN = 1;\par
SYSCLK->CLKSEL0.HCLK_S = 0;\par
LOCKREG();\par
\par
InitPWM();\par
InitADC();\par
\par
Initial_panel(); \~//call initial pannel function\par
clr_all_panel();\par
/* Synch field transmission & Request Identifier Field transmission*/\par
\~\par
while(1)\par
\{\par
while(ADC->ADSR.ADF==0);\par
ADC->ADSR.ADF=1;\par
PWMA->CMR0=ADC->ADDR[6].RSLT<<4;\par
Show_Word(0,11,' ');\par
Show_Word(0,12,' ');\par
Show_Word(0,13,' ');\par
sprintf(adc_value+10,"%d",ADC->ADDR[6].RSLT);\par
print_lcd(0, adc_value);\par
Delay(20000);\par
ADC->ADCR.ADST=1;\par
\}\par
\}\par

\pard\sa200\sl276\slmult1\f1\fs22\lang9\par

\pard\widctlpar\li360\sa200\sl276\slmult1\qj\f0\fs24\lang1033 7.Using pwm0 change the illumination of external led connected to port A12.\par

\pard\widctlpar\qj #include <stdio.h> \~\par
#include "NUC1xx.h"\par
#include "LCD_Driver.h"\par
#define BAUDRATE 9600\par
\par
void InitADC(void)\par
\{\par
/* Step 1. GPIO initial */\~\par
GPIOA->OFFD|=0x00800000; //Disable digital input path\par
SYS->GPAMFP.ADC7_SS21_AD6=1; //Set ADC function\~\par
/* Step 2. Enable and Select ADC clock source, and then enable ADC module */ \~ \~ \~ \~ \~\par
SYSCLK->CLKSEL1.ADC_S = 2; //Select 22Mhz for ADC\par
SYSCLK->CLKDIV.ADC_N = 1; //ADC clock source = 22Mhz/2 =11Mhz;\par
SYSCLK->APBCLK.ADC_EN = 1; //Enable clock source\par
ADC->ADCR.ADEN = 1; //Enable ADC module\par
\par
/* Step 3. Select Operation mode */\par
ADC->ADCR.DIFFEN = 0; \~ \~ //single end input\par
ADC->ADCR.ADMD \~ = 0; \~ \~ //single mode\par
/* Step 4. Select ADC channel */\par
ADC->ADCHER.CHEN = 0x80;\par
/* Step 5. Enable ADC interrupt */\par
ADC->ADSR.ADF =1; \~ \~ //clear the A/D interrupt flags for safe\~\par
ADC->ADCR.ADIE = 1;\par
// NVIC_EnableIRQ(ADC_IRQn);\par
/* Step 6. Enable WDT module */\par
ADC->ADCR.ADST=1;\par
\}\par
//--------------------------------------------\par
void InitPWM(void)\par
\{\par
\~ /* Step 1. GPIO initial */\~\par
SYS->GPAMFP.PWM0_AD13=1;\par
/* Step 2. Enable and Select PWM clock source*/ \par
SYSCLK->APBCLK.PWM01_EN = 1;//Enable PWM clock\par
SYSCLK->CLKSEL1.PWM01_S = 3;//Select 22.1184Mhz for PWM clock source\par
\par
PWMA->PPR.CP01=1; //Prescaler 0~255, Setting 0 to stop output clock\par
PWMA->CSR.CSR0=0; // PWM clock = clock source/(Prescaler + 1)/divider\par
\~ \~ \~ \~\~\par
/* Step 3. Select PWM Operation mode */\par
//PWM0\par
PWMA->PCR.CH0MOD=1; //0:One-shot mode, 1:Auto-load mode\par
//CNR and CMR will be auto-cleared after setting CH0MOD form 0 to 1.\par
PWMA->CNR0=0xFFFF;\par
PWMA->CMR0=0xFFFF;\par
\par
PWMA->PCR.CH0INV=0; //Inverter->0:off, 1:on\par
PWMA->PCR.CH0EN=1; //PWM function->0:Disable, 1:Enable\par
\~ PWMA->POE.PWM0=1; //Output to pin->0:Diasble, 1:Enable\par
\}\par
\par
void Delay(int count)\par
\{\par
while(count--)\par
\{\par
// __NOP;\par
\}\par
\}\par
\par
/*----------------------------------------------------------------------------\par
\~ MAIN function\par
\~ ----------------------------------------------------------------------------*/\par
int32_t main (void)\par
\{\par
//Enable 12Mhz and set HCLK->12Mhz\par
char adc_value[15]="ADC Value:"; \par
UNLOCKREG();\par
SYSCLK->PWRCON.XTL12M_EN = 1;\par
SYSCLK->CLKSEL0.HCLK_S = 0;\par
LOCKREG();\par
\par
InitPWM();\par
InitADC();\par
\par
Initial_panel(); \~//call initial pannel function\par
clr_all_panel();\par
/* Synch field transmission & Request Identifier Field transmission*/\par
\~\par
while(1)\par
\{\par
while(ADC->ADSR.ADF==0);\par
ADC->ADSR.ADF=1;\par
PWMA->CMR0=ADC->ADDR[7].RSLT<<4;\par
Show_Word(0,11,' ');\par
Show_Word(0,12,' ');\par
Show_Word(0,13,' ');\par
sprintf(adc_value+10,"%d",ADC->ADDR[7].RSLT);\par
print_lcd(0, adc_value);\par
Delay(20000);\par
ADC->ADCR.ADST=1;\par
\}\par
\}\par
\par

\pard\widctlpar\li360\sa200\sl276\slmult1\qj 8) TO SWITCH ON/OFF BULB USING RELAY\par

\pard\widctlpar\li720\sa200\sl276\slmult1\qj\par
//\par
// Smpl_GPIO_EINT1 : External Interrupt pin to trigger interrupt on GPB15, then Buzz\par
\par
#include <stdio.h>\par
#include "NUC1xx.h"\par
#include "Driver\\DrvGPIO.h"\par
#include "Driver\\DrvUART.h"\par
#include "Driver\\DrvSYS.h"\par
\par
// External Interrupt Handler (INT button to trigger GPB15)\par
void EINT1Callback(void) \par
\{\par
  DrvGPIO_ClrBit(E_GPA,0); // GPB11 = 0 to turn on Buzzer\par
\tab DrvSYS_Delay(10);\tab     // Delay \par
\tab //DrvGPIO_SetBit(E_GPA,0); // GPB11 = 1 to turn off Buzzer\tab\par
\tab DrvSYS_Delay(10000);\tab     // Delay \tab\par
\}\par
\par
int main (void)\par
\{\par
\tab UNLOCKREG();\par
\tab DrvSYS_SetOscCtrl(E_SYS_XTL12M, 1); // external 12MHz Crystal\par
\tab //DrvSYS_Delay(5000);                 // delay for stable clock\par
\tab DrvSYS_SelectHCLKSource(0);         // clock source = 12MHz Crystal\par
\tab LOCKREG();\par
\par
\tab DrvGPIO_Open(E_GPA, 0, E_IO_OUTPUT); // initial GPIO pin GPB11 for controlling Buzzer\par
   \par
//0 External Interrupt \par
  DrvGPIO_Open(E_GPB, 15, E_IO_INPUT);                             // configure external interrupt pin GPB15\par
  DrvGPIO_EnableEINT1(E_IO_BOTH_EDGE, E_MODE_EDGE, EINT1Callback); // configure external interrupt\par
\par
  while(1)\par
\tab\{\par
  \}\par
\}\par
\par

\pard\widctlpar\sa200\sl276\slmult1\qj 9. ldr program\par
//\par
// Smpl_ADC_VR1 : use ADC7 to read Variable Resistor (on-board)\par
//\par
#include <stdio.h>\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab  \par
#include "NUC1xx.h"\par
#include "DrvSYS.h"\par
#include "NUC1xx-LB_002\\LCD_Driver.h"\par
\par
void InitADC(void)\par
\{\par
\tab /* Step 1. GPIO initial */ \par
\tab GPIOA->OFFD|=0x00400000; \tab //Disable digital input path\par
\tab SYS->GPAMFP.ADC7_SS21_AD6=1; \tab\tab //Set ADC function \par
\tab\tab\tab\tab\par
\tab /* Step 2. Enable and Select ADC clock source, and then enable ADC module */          \par
\tab SYSCLK->CLKSEL1.ADC_S = 2;\tab //Select 22Mhz for ADC\par
\tab SYSCLK->CLKDIV.ADC_N = 1;\tab //ADC clock source = 22Mhz/2 =11Mhz;\par
\tab SYSCLK->APBCLK.ADC_EN = 1;\tab //Enable clock source\par
\tab ADC->ADCR.ADEN = 1;\tab\tab\tab //Enable ADC module\par
\par
\tab /* Step 3. Select Operation mode */\par
\tab ADC->ADCR.DIFFEN = 0;     \tab //single end input\par
\tab ADC->ADCR.ADMD   = 0;     \tab //single mode\par
\tab\tab\par
\tab /* Step 4. Select ADC channel */\par
\tab ADC->ADCHER.CHEN = 0x40;\par
\tab\par
\tab /* Step 5. Enable ADC interrupt */\par
\tab ADC->ADSR.ADF =1;     \tab\tab //clear the A/D interrupt flags for safe \par
\tab ADC->ADCR.ADIE = 1;\par
//\tab NVIC_EnableIRQ(ADC_IRQn);\par
\tab\par
\tab /* Step 6. Enable WDT module */\par
\tab ADC->ADCR.ADST=1;\par
\}\par
\par
/*----------------------------------------------------------------------------\par
  MAIN function\par
  ----------------------------------------------------------------------------*/\par
int32_t main (void)\par
\{\par
\tab char TEXT1[16]="ADC Value:      ";\tab\par
\tab UNLOCKREG();\par
\tab //SYSCLK->PWRCON.XTL12M_EN = 1; // enable external clock (12MHz)\par
\tab //SYSCLK->CLKSEL0.HCLK_S = 0;\tab   // select external clock (12MHz)\par
\tab LOCKREG();\par
\par
\tab InitADC();\tab\tab     // initialize ADC\par
\par
\tab Initial_panel();  // initialize LCD pannel\par
\tab clr_all_panel();  // clear LCD panel \par
\tab print_lcd(0, "Smpl_ADC_VR1");\par
\tab\tab\tab\tab\tab\tab\tab  \tab\tab\tab\tab\tab  \par
\tab while(1)\par
\tab\{\par
\tab\tab while(ADC->ADSR.ADF==0); // wait till conversion flag = 1, conversion is done\par
\tab\tab ADC->ADSR.ADF=1;\tab\tab      // write 1 to clear the flag\par
\tab\tab sprintf(TEXT1+10,"%4d",ADC->ADDR[6].RSLT); // convert ADC7 value into text\par
\tab\tab print_lcd(1, TEXT1);\tab    // output TEXT to LCD\par
\tab\tab DrvSYS_Delay(20000);\tab    // delay\par
\tab\tab ADC->ADCR.ADST=1;\tab\tab      // restart ADC sample\par
\tab\}\par
\}\par
\par
\par
10)stepper motor\par

\pard\widctlpar\qj\tx916\tx1832\tx2748\tx3664\tx4580\tx5496\tx6412\tx7328\tx8244\tx9160\tx10076\tx10992\tx11908\tx12824\tx13740\tx14656\cf1 //\par
// Sampl_GPIO_StepMotor \par
// 5V Step Motor 28BYJ-48, driver IC = ULN2003A\par
//\par
// Driver board connections:\par
// ULN2003A    NUC140\par
// INA      to GPA3\par
// INB      to GPA2\par
// INC      to GPA1\par
// IND      to GPA0\par
//\par
#include <stdio.h>\par
#include "NUC1xx.h"\par
#include "Driver\\DrvGPIO.h"\par
#include "Driver\\DrvSYS.h"\par
\par
// Definitions for Step Motor turning degree\par
#define d360 512\par
#define d180 512/2\par
#define d90  512/4\par
#define d45  512/8\par
#define d2 51\par
\par
unsigned char CW[8] =\{0x09,0x01,0x03,0x02,0x06,0x04,0x0c,0x08\}; //Clockwise Sequence\par
unsigned char CCW[8]=\{0x08,0x0c,0x04,0x06,0x02,0x03,0x01,0x09\}; //Counter-Clockwise Sequence\par
\par
void CW_MOTOR(uint16_t deg)\par
\{\par
 int i=0,j=0;\par
\par
for(j=0;j<(deg);j++)\par
\{\par
    for(i=0;i<8;i++)\par
\tab\{\par
\tab GPIOA->DOUT=CW[i];\par
\tab DrvSYS_Delay(20000);//delay 2000us = 2ms\par
\tab\}\par
 \}\par
\}\par
\par
void CCW_MOTOR(uint16_t deg)\par
\{\par
 int i=0,j=0;\par
\par
for(j=0;j<(deg);j++)\par
\{\par
    for(i=0;i<8;i++)\par
\tab\{\par
\tab GPIOA->DOUT=CCW[i];\par
\tab DrvSYS_Delay(20000);//delay 2000us = 2ms\par
\tab\}\par
 \}\par
\}\par
\par
int main (void)\par
\{  \tab\par
\tab CW_MOTOR(d2); // Clockwise         for 360 degree\par
\tab //CCW_MOTOR(d2/2);// Counter-Clockwise for 180 degree\par
\}\par

\pard\sa200\sl276\slmult1\cf0\f1\fs22\lang9\par
}
 